# Cursor Rules for Bhuvesh Portfolio Project

## Project Overview
This is a Next.js 15 portfolio website with TypeScript, Tailwind CSS, and a well-organized component structure.

## Tech Stack
- **Framework**: Next.js 15 with App Router
- **Language**: TypeScript
- **Styling**: Tailwind CSS
- **Animations**: Framer Motion
- **Build Tool**: Turbopack

## Project Structure
```
src/
â”œâ”€â”€ app/                    # Next.js App Router pages
â”œâ”€â”€ components/             # Reusable React components
â”‚   â”œâ”€â”€ ui/                # UI components (Button, Card, Section, Loading, SVG)
â”‚   â”œâ”€â”€ layout/            # Layout components (Navigation)
â”‚   â””â”€â”€ sections/          # Page sections (Hero, About, Projects, Contact)
â”œâ”€â”€ lib/                   # Utility functions and data
â”œâ”€â”€ types/                 # TypeScript type definitions
â””â”€â”€ assets/               # Static assets
```

## Coding Standards

### TypeScript
- Always use TypeScript for all files
- Define proper interfaces and types in `/types/index.ts`
- Use strict type checking
- Prefer interfaces over types for object shapes
- Export types from a central location

### React Components
- Use functional components with hooks
- Always define proper prop types
- Use React.FC for component typing
- Keep components small and focused
- Use descriptive component names

### File Naming
- Use PascalCase for component files: `Button.tsx`
- Use camelCase for utility files: `data.ts`
- Use kebab-case for page routes: `page.tsx`

### Import Organization
1. React imports first
2. Third-party libraries
3. Internal components (use absolute imports with `@/`)
4. Types and utilities
5. Relative imports last

### Component Structure
```tsx
import React from 'react';
import { ComponentProps } from '@/types';

interface ComponentNameProps {
  // Define props here
}

export const ComponentName: React.FC<ComponentNameProps> = ({
  // Destructure props
}) => {
  // Component logic

  return (
    // JSX
  );
};

export default ComponentName;
```

### Styling Guidelines
- Use Tailwind CSS classes
- Follow mobile-first responsive design
- Use consistent color scheme (cyan-400, blue-500, etc.)
- Use backdrop-blur and glassmorphism effects
- Maintain consistent spacing and typography

### Data Management
- Store all static data in `/lib/data.ts`
- Use TypeScript interfaces for data structures
- Keep data separate from components
- Use descriptive variable names

### SVG Icons
- Use the custom SVG component system
- Add new icons to the `Icons` object in `SVG.tsx`
- Use consistent sizing (w-6 h-6, w-5 h-5, etc.)
- Prefer stroke icons over filled when possible

## Best Practices

### Performance
- Use dynamic imports for large components
- Optimize images and assets
- Use React.memo for expensive components
- Implement proper loading states

### Accessibility
- Use semantic HTML elements
- Add proper ARIA labels
- Ensure keyboard navigation
- Maintain color contrast ratios

### Code Quality
- Write self-documenting code
- Use meaningful variable and function names
- Keep functions small and focused
- Add comments for complex logic
- Follow DRY (Don't Repeat Yourself) principle

### Git Workflow
- Use descriptive commit messages
- Create feature branches for new features
- Keep commits atomic and focused
- Use conventional commit format when possible

## Component Guidelines

### UI Components
- Make components reusable and configurable
- Use consistent prop interfaces
- Provide sensible defaults
- Support className overrides

### Layout Components
- Keep layout components flexible
- Use CSS Grid and Flexbox appropriately
- Ensure responsive behavior
- Handle mobile navigation properly

### Section Components
- Keep sections focused on single responsibility
- Use consistent spacing and styling
- Make sections reusable across pages
- Handle data through props or data imports

## Development Commands
```bash
npm run dev          # Start development server
npm run build        # Build for production
npm run start        # Start production server
npm run lint         # Run ESLint
npm run lint:fix     # Fix ESLint errors
npm run format       # Format code with Prettier
```

## File Organization Rules
- Keep related files together
- Use index.ts files for clean exports
- Group components by functionality
- Separate concerns (UI, logic, data)

## Error Handling
- Use proper error boundaries
- Handle loading and error states
- Provide meaningful error messages
- Log errors appropriately

## Testing Considerations
- Write testable components
- Keep business logic separate from UI
- Use proper prop validation
- Consider accessibility testing

## Performance Considerations
- Optimize bundle size
- Use code splitting appropriately
- Minimize re-renders
- Optimize images and assets

## Security
- Sanitize user inputs
- Use proper authentication patterns
- Follow Next.js security best practices
- Keep dependencies updated

## ðŸš€ OPTIMIZATION GUIDELINES

### DRY Principle Compliance
- **NEVER duplicate code** - Use shared utilities and components
- **Centralize common patterns** - Use `componentPatterns.ts` for UI patterns
- **Unified API layer** - Use `unifiedClient.ts` for all API calls
- **Single theme system** - Use `useThemeStyles` hook consistently

### Performance Optimization
- **Memoization**: Use `React.memo` for expensive components
- **Lazy Loading**: Use dynamic imports for heavy components
- **Bundle Optimization**: Use tree shaking and code splitting
- **API Optimization**: Use retry logic and timeout handling

### Code Organization
- **Utility Functions**: Place in `/lib/utils/` with clear naming
- **Component Patterns**: Use `/lib/utils/componentPatterns.ts` for common UI patterns
- **API Layer**: Use `/lib/api/unifiedClient.ts` for all API calls
- **Theme System**: Use `/hooks/useThemeStyles.ts` for theme-aware styling

### Type Safety
- **Strict TypeScript**: Enable strict mode everywhere
- **API Types**: Use generated types from backend schemas
- **Component Props**: Define proper interfaces for all props
- **Error Handling**: Use typed error interfaces

### Responsive Design
- **Mobile First**: Always start with mobile design
- **Breakpoints**: Use consistent Tailwind breakpoints
- **Responsive Utilities**: Use `responsivePadding`, `responsiveTextSizes` from componentPatterns
- **Touch Targets**: Ensure minimum 44px touch targets

### Accessibility
- **Semantic HTML**: Use proper HTML elements
- **ARIA Labels**: Add proper ARIA attributes
- **Keyboard Navigation**: Ensure all interactive elements are keyboard accessible
- **Color Contrast**: Maintain WCAG AA compliance

### Error Handling
- **Centralized**: Use unified error handling patterns
- **User-Friendly**: Provide meaningful error messages
- **Retry Logic**: Implement automatic retry for failed requests
- **Fallbacks**: Provide graceful degradation

### Testing
- **Unit Tests**: Test utility functions and hooks
- **Component Tests**: Test component behavior and accessibility
- **Integration Tests**: Test API interactions
- **E2E Tests**: Test critical user flows

## ðŸŽ¯ OPTIMIZATION CHECKLIST

Before committing code, ensure:
- [ ] No code duplication (DRY principle)
- [ ] Proper TypeScript types
- [ ] Responsive design implementation
- [ ] Accessibility compliance
- [ ] Performance optimization (memo, lazy loading)
- [ ] Error handling implementation
- [ ] Theme system consistency
- [ ] API layer usage (unified client)
- [ ] Component pattern compliance
- [ ] Clean imports and exports

Remember: This is a portfolio website, so focus on clean code, good performance, and excellent user experience. The code should be maintainable and showcase best practices.
